# Sliding Window

* 双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。

````c
left, right := 0, -1

	for left < len(s) {
		if right+1 < len(s) && freq[s[right+1]-'a'] == 0 {
			freq[s[right+1]-'a']++
			right++
		} else {
			freq[s[left]-'a']--
			left++
		}
		result = max(result, right-left+1)
	}
````

* 滑动窗口经典题。第 239 题，第 480 题。



# Two Pointers

- SUM 问题集。第 1 题，第 15 题，第 16 题，第 18 题，第 167 题，第 923 题，第 1074 题。

# BinarySearch

* 注意事项
  * 循环退出的条件（根据能否确定元素存在于序列中）、mid 的取值方法（注意溢出问题的处理），左右边界的更新

* 在基本有序的序列中进行查找，查找山峰，旋转数组中进行查找第 33 题，第 81 题，第 153 题，第 154 题，第 162 题，第 852 题
* max-min 最大值最小化问题，第 410 题，第 875 题，第 1011 题，第 1283 题（未做）。

# Stack

* 括号匹配问题：20、921、1021题
* 栈的push 和 pop 基本操作：71、150、155、224
* 用栈进行编码问题：394、682、856、880
* 单调栈的使用：第 84 题，第 456 题，第 496 题，第 503 题，第 739 题，第 901 题，第 907 题，第 1019 题。
  * 对于**找最近一个比当前值大/小**的问题，都可以使用单调栈来解决。单调栈就是在栈的基础上维护一个栈内元素单调。 

# Linked List

* 构造虚拟头节点，可以使遍历链表的处理逻辑统一。
* 利用好递归，可以使解题更加方便，
* 新建立一个链表的开销比数组小很多，一般只需要新构造一个节点。
* 链表区间逆序：92
* 链表寻找中间节点：876，链表寻找倒数第 n 个节点，19
* 合并 K 个有序链表，21, 23
* 链表归类 86， 328
* 判断链表中是否有环 141、142
* 判断两个链表是否有交叉点 160
* 删除链表中重复的元素 142、143
* 链表的排序：148

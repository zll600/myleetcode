# 滑动窗口（Sliding Window）

* 双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。

````c
left, right := 0, -1

	for left < len(s) {
		if right+1 < len(s) && freq[s[right+1]-'a'] == 0 {
			freq[s[right+1]-'a']++
			right++
		} else {
			freq[s[left]-'a']--
			left++
		}
		result = max(result, right-left+1)
	}
````

* 滑动窗口经典题。第 239 题，第 480 题。
* 第 1343 题，第 1456 题，第 1525 题，第 1695 题，第 1888 题、第 209 题



# 双指针（Two Pointers）

- SUM 问题集。第 1 题，第 15 题，第 16 题，第 18 题，第 167 题，第 923 题，第 1074 题。

# 二分查找（BinarySearch）

* 注意事项
  * 循环退出的条件（根据能否确定元素存在于序列中）、mid 的取值方法（注意溢出问题的处理），左右边界的更新
* 在基本有序的序列中进行查找，查找山峰，旋转数组中进行查找第 33 题，第 81 题，第 153 题，第 154 题，第 162 题，第 852 题
* max-min 最大值最小化问题，第 410 题，第 875 题，第 1011 题，第 1283 题（未做）。
* 第 441 题，第 611 题

# 栈（Stack）

* 括号匹配问题：20、921、1021题
* 栈的push 和 pop 基本操作：71、150、155、224
* 用栈进行编码问题：394、682、856、880
* 单调栈的使用：第 42 题，第 84 题，第 85 题，第 456 题，第 496 题，第 503 题，第 739 题，第 901 题，第 907 题，第 1019 题，第 42 题
  * 对于**找最近一个比当前值大/小**的问题，都可以使用单调栈来解决。单调栈就是在栈的基础上维护一个栈内元素单调。
* 双栈法解决计算器类问题

# 链表（Linked List)

* 构造虚拟头节点，可以使遍历链表的处理逻辑统一。
* 利用好递归，可以使解题更加方便，这个真的很重要，第25 题，第 23 题都有，
* 新建立一个链表的开销比数组小很多，一般只需要新构造一个节点。
* 链表区间逆序：92
* 链表寻找中间节点：876，链表寻找倒数第 n 个节点，19
* 合并 K 个有序链表，21, 23
* 链表归类 86， 328
* 判断链表中是否有环 141、142
* 判断两个链表是否有交叉点 160
* 删除链表中重复的元素 142、143
* 链表的排序：148
* 交换节点顺序：第24、25题

# 树(Tree)

* 树的大部分问题都是树的遍历问题，尽量掌握树的三种遍历的递归和迭代写法
* 二叉搜索树：第 783 题、 第 530 题、第 938 题 
* 树的遍历：第 94 题、第 144 题，第 145 题， 第 221 题、第 987 题、第965 题、第 102 题
* 比较二叉树中的元素：第 226 题、第 100 题、第 101 题、第 572 题
* 二叉树的高度和深度：第104 题、第 110 题、第 111 题
* 树的构建：第 1008 题
* 863、993、872、897、

# 回溯算法（Backtracking）

* 回溯问题，大多需要转化为树形结构，然后进行去重和剪枝操作，
* 组合问题：第 17 题、第 39 题、第 40 题、第 77 题、第 216 题
* 排列问题：第 46 题、第 47 题、第 60 题、第 526 题、第 996 题
* 排列加组合： 第 1079 题
* 子集问题：第 78 题、第 90 题、第 491 题
* 暴力搜索问题：第 79 题，第 212 题，第 980 题，第 733 题
* 字符串：第 17 题，第 784 题，第 22 题
* 第698 题（我觉得是组合）

# 深度优先搜索（DFS）

* DFS 和 BFS 本质上都是一种状态转移，如果是关心过程更常用，如果更关心结果，则动态规划使用的多一些，两中四思想解决的问题都是图的遍历（树也是一种特殊的图）
* 双向 DFS （1755）
* 第 22 题

# 广度优先搜索（BFS）

* 126\127\279
* 同样使先化为一棵树或者一幅图，然后进行 BFS 来解决
* 第 365 题
* 第 22 题

# 动态规划（Dynamic Programming）

* 路径 DP ：62、63、64、120、931、1289、1575
* 背包DP：
  * 01 背包 ：416、474、494、879
  * 完全背包：322、518、1449
* 线性dp:
* 第 212、第 79 题、第 152 题

# 前缀和(Prefix Sum)

* 前缀和主要用来解决区间求和问题
* 相关题目
* 第 560 题

# 字典树(Tries)

* 如果题目需要大量的判但字符串和给定单词列表的前缀/或者后缀（将单词倒着插入就可以进行后缀匹配）
* 题目：208、211、421、648、677、1707、820

# 并查集(UnionFind)

* 并查集主要用来解决动态连通性问题，重点关注的是连接，而不是路径问题

* 题目：208、211、155、677、421、1707、820、648、803、952

# 位运算（Bit Mainpulation）

* 异或：136、137、389
* 有特殊意义的 & 操作：第 260 题，第 201 题，第 318 题，第 371 题，第 397 题，第 461 题，第 693 题，
* 190、191、338、342、461、477、1178、1711

# 贪心算法（Greedy）

* 12 、45、179、502、452、561、765、781、881、995、1221、1707、1713、1736、1833、1846、1877

# 排序（Sort）

* 选择排序（了解）
* 插入排序（熟悉）
* 归并排序（重点）：88题、315题、剑指51题
* 快速排序（重点）：215题、75题
* 堆排序（重点）

# 哈希表（Hash Table）

* 1、36、49、202、127、219、454
* 981、447、448

# 模拟(Stimulation)

* 第 1 题、第 2 题、第 5 题、第 6 题、第 7 题、第238题、第 498 题，

# 数学（Math）

* 441 题，29题

# 字符串（String）

* 第 273 题，第 43 题


# Sliding Window

* 双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。

````c
left, right := 0, -1

	for left < len(s) {
		if right+1 < len(s) && freq[s[right+1]-'a'] == 0 {
			freq[s[right+1]-'a']++
			right++
		} else {
			freq[s[left]-'a']--
			left++
		}
		result = max(result, right-left+1)
	}
````

* 滑动窗口经典题。第 239 题，第 480 题。



# Two Pointers

- SUM 问题集。第 1 题，第 15 题，第 16 题，第 18 题，第 167 题，第 923 题，第 1074 题。

# BinarySearch

* 注意事项
  * 循环退出的条件（根据能否确定元素存在于序列中）、mid 的取值方法（注意溢出问题的处理），左右边界的更新

* 在基本有序的序列中进行查找，查找山峰，旋转数组中进行查找第 33 题，第 81 题，第 153 题，第 154 题，第 162 题，第 852 题
* max-min 最大值最小化问题，第 410 题，第 875 题，第 1011 题，第 1283 题（未做）。

# Stack

* 括号匹配问题：20、921、1021题
* 栈的push 和 pop 基本操作：71、150、155、224
* 用栈进行编码问题：394、682、856、880
* 单调栈的使用：第 84 题，第 456 题，第 496 题，第 503 题，第 739 题，第 901 题，第 907 题，第 1019 题。
  * 对于**找最近一个比当前值大/小**的问题，都可以使用单调栈来解决。单调栈就是在栈的基础上维护一个栈内元素单调。 

# Linked List

* 构造虚拟头节点，可以使遍历链表的处理逻辑统一。
* 利用好递归，可以使解题更加方便，这个真的很重要，第25 题，第 23 题都有，
* 新建立一个链表的开销比数组小很多，一般只需要新构造一个节点。
* 链表区间逆序：92
* 链表寻找中间节点：876，链表寻找倒数第 n 个节点，19
* 合并 K 个有序链表，21, 23
* 链表归类 86， 328
* 判断链表中是否有环 141、142
* 判断两个链表是否有交叉点 160
* 删除链表中重复的元素 142、143
* 链表的排序：148
* 交换节点顺序：第24、25题

# Tree

* 树的大部分问题都是树的遍历问题，尽量掌握树的三种遍历的递归和迭代写法
* 二叉搜索树：783. 530. 938 
* 863、993、872、897、

# Backtracking

* 回溯问题，大多需要转化为树形结构，然后进行去重和剪枝操作，
* 组合问题：17、39、40、77、216
* 排列问题：46、47、60、526、996
* 排列加组合 1079
* 子集问题：78、90、491
* 暴力搜索问题：79,212.980,733
* 字符串：17、784、22

# DFS

* DFS 和 BFS 本质上都是一种状态转移，如果是关心过程更常用，如果更关心结果，则动态规划使用的多一些，两中四思想解决的问题都是图的遍历（树也是一种特殊的图）

# BFS

* 126\127\279
* 同样使先化为一棵树或者一幅图，然后进行 BFS 来解决

## Dynamic Programming

* 路径 DP ：62、63、64、120、931、1289、1575
* 背包DP：
  * 01 背包 ：416、474、494、879
  * 完全背包：322、518、1449
* 线性dp:

# 前缀和

* 前缀和主要用来解决区间求和问题
* 相关题目

# 字典树

* 如果题目需要大量的判但字符串和给定单词列表的前缀/或者后缀（将单词倒着插入就可以进行后缀匹配）
* 题目：208、211、421、648、677、1707、820

# 并查集

* 并查集主要用来解决动态连通性问题，重点关注的是连接，而不是路径问题

````
// quick-find

````


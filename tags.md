# 滑动窗口（Sliding Window）

* 双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。

````c
left, right := 0, -1

	for left < len(s) {
		if right+1 < len(s) && freq[s[right+1]-'a'] == 0 {
			freq[s[right+1]-'a']++
			right++
		} else {
			freq[s[left]-'a']--
			left++
		}
		result = max(result, right-left+1)
	}
````

* 滑动窗口经典题。第 239 题，第 480 题。
* 第 1343 题，第 1456 题，第 1525 题，第 1695 题，第 1888 题、第 209 题、第 228 题、第 395 题
* 第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。
* 第 862 题、第 1234 题、第 1248 题、第 1358 题



# 双指针（Two Pointers）

* 双指针常用来在数组中进行遍历来减少一层循环，当然也可以同时遍历两个数组

- SUM 问题集。第 1 题，第 15 题，第 16 题，第 18 题，第 167 题，第 923 题，第 1074 题。
- 第 917 题、第 925 题、第 986 题、第 855 题、第 415 题，
- 同时遍历两个数组： 第 844 题，

# 二分查找（BinarySearch）

* 注意事项
  * 循环退出的条件（根据能否确定元素存在于序列中）、mid 的取值方法（注意溢出问题的处理），左右边界的更新
* 在基本有序的序列中进行查找，查找山峰，旋转数组中进行查找第 33 题，第 81 题，第 153 题，第 154 题，第 162 题，第 852 题
* max-min 最大值最小化问题，第 410 题，第 875 题，第 1011 题，第 1283 题（未做）。
* 第 441 题，第 611 题、第 367 题、第 378 题、第 795 题

# 栈（Stack）

* 括号匹配问题：第 20 题、第 921 题、第 1021 题
* 栈的push 和 pop 基本操作：第 71 题、第 150 题、第 155 题、第 224 题
* 用栈进行编码问题：第 394 题、第 682 题、第 856 题、第 880 题
* 单调栈的使用：第 42 题，第 84 题，第 85 题，第 456 题，第 496 题，第 503 题，第 739 题，第 901 题，第 907 题，第 1019 题，第 42 题
  * 对于**找最近一个比当前值大/小**的问题，都可以使用单调栈来解决。单调栈就是在栈的基础上维护一个栈内元素单调。
  * 利用单调栈来进行数组去重：第 402 题、第 316 题、第 321 题、第 1081 题
* 双栈法解决计算器类问题
* 利用栈的后进先出的特点：第 844 题，第 385 题、第 388 题

# 队列 (Queue)

* 利用队列先进先出的特性：第 933 题





# 链表（Linked List)

* 构造虚拟头节点，可以使遍历链表的处理逻辑统一。
* 利用好递归，可以使解题更加方便，这个真的很重要，第25 题，第 23 题都有，
* 新建立一个链表的开销比数组小很多，一般只需要新构造一个节点。
* 链表区间逆序：92
* 链表寻找中间节点：876，链表寻找倒数第 n 个节点，19
* 合并 K 个有序链表，21, 23
* 链表归类 86， 328
* 判断链表中是否有环 141、142
* 判断两个链表是否有交叉点 160
* 删除链表中重复的元素 142、143
* 链表的排序：148
* 交换节点顺序：第24、25题

# 树(Tree)

* 树的大部分问题都是树的遍历问题，尽量掌握树的三种遍历的递归和迭代写法
* 二叉搜索树：第 783 题、 第 530 题、第 938 题 
* 树的遍历：第 94 题、第 144 题，第 145 题， 第 221 题、第 987 题、第965 题、第 102 题、第 508 题、第 515 题
* 比较二叉树中的元素：第 226 题、第 100 题、第 101 题、第 572 题
* 二叉树的高度和深度：第104 题、第 110 题、第 111 题
* 二叉树的路径问题：第 257 题、第 112 题、第 113 题，第 437题、第 988 题、第 124 题、第 687 题、第 543 题
* 树的构建：第 1008 题、第 96 题，第 95 题
* 第 863 题、第 993 题、第 872 题、第 897 题、

# 回溯算法（Backtracking）

* 回溯问题，大多需要转化为树形结构，然后进行去重和剪枝操作，
* 组合问题：第 17 题、第 39 题、第 40 题、第 77 题、第 216 题
* 排列问题：第 46 题、第 47 题、第 60 题、第 526 题、第 996 题
* 排列加组合： 第 1079 题
* 子集问题：第 78 题、第 90 题、第 491 题
* 暴力搜索问题：第 79 题，第 212 题，第 980 题，第 733 题
* 字符串：第 17 题，第 784 题，第 22 题
* 第698 题（我觉得是组合）、第 301 题
* 状态转移：第 403 题

# 深度优先搜索（DFS）

* DFS 和 BFS 本质上都是一种状态转移，如果是关心过程更常用，如果更关心结果，则动态规划使用的多一些，两中四思想解决的问题都是图的遍历（树也是一种特殊的图）
* DFS 相比 BFS 更容易加入记忆化
* 双向 DFS：第1755 题，第 417 题
* 第 22 题、第 282 题、第 385 题、第 386 题、第 395 题
* 岛屿问题：第 419 题

# 广度优先搜索（BFS）

* 如果题目中隐含与最短路径相关，那么就要考虑使用 BFS 来解决，会比使用 DFS 更高效一点
* 第 126 题、第127 题、第 279 题
* 同样使先化为一棵树或者一幅图，然后进行 BFS 来解决
* 第 365 题、
* 求最短路径：第 542 题、第 934 题、第 675 题、第 433 题
* 第 22 题、
* 拓扑排序：第 207 题、第 210 题
* 双向BFS：第 417 题、第 433 题

# 动态规划（Dynamic Programming）

* 这个专题，放上一篇写的很棒的题解：https://leetcode-cn.com/circle/article/2Xxlw3/
* 路径 DP ：62、63、64、120、931、1289、1575
* 背包DP：
  * 01 背包 ：416、474、494、879
  * 完全背包：322、518、1449
* 线性dp: 
* 第 212、第 79 题、第 152 题、第 368 题、第 372 题、第 313 题、第 354 题
* 区间DP：第 312 题，第 486 题、第 664 题、第 546 题、第 375 题

````
区间dp 可以参考这篇文章
一般的特征就是大区间的状态依赖于小区间的状态
https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489400&idx=1&sn=0b629d3669329a6bf4f6ec71c2571ce7&chksm=fd9cbc67caeb357132fe0a1ca6240e2183748d94039100f539193d3eeb1dc223e0ddd4aa9584&scene=178&cur_album_id=2004942489941606403#rd
````



# 前缀和(Prefix Sum)

* 前缀和主要用来解决区间求和问题
* 相关题目
* 第 560 题、第 209 题、第 862 题、第 1248 题

# 字典树(Tries)

* 如果题目需要大量的判但字符串和给定单词列表的前缀/或者后缀（将单词倒着插入就可以进行后缀匹配）
* trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能
* 参考资料：https://zh.wikipedia.org/wiki/Trie
* 题目：第 208 题、第 211 题、第 421 题、第 648 题、第 677 题、第 1707 题、第 820 题、第 676 题
* 第 336 题，

# 并查集(UnionFind)

* 并查集主要用来解决动态连通性问题，重点关注的是连接，而不是路径问题

* 题目：208、211、155、677、421、1707、820、648、803、952

# 位运算（Bit Mainpulation）

注：这里是从霜神那里白嫖的，

* 异或：136、137、389

* ```
  x ^ 0 = x
  x ^ 11111……1111 = ~x
  x ^ (~x) = 11111……1111
  x ^ x = 0
  a ^ b = c  => a ^ c = b  => b ^ c = a (交换律)
  a ^ b ^ c = a ^ (b ^ c) = (a ^ b）^ c (结合律)
  ```

* 有特殊意义的 & 操作：第 260 题，第 201 题，第 318 题，第 371 题，第 397 题，第 461 题，第 693 题，第 868 题

* ````
  X & 1 == 1 判断是否是奇数(偶数)
  X & = (X - 1) 将最低位(LSB)的 1 清零
  X & -X 得到最低位(LSB)的 1
  X & ~X = 0
  ````

* 190、191、338、342、461、477、1178、1711

* 构造特殊 Mask，将特殊位置放 0 或 1

* ```
  将 x 最右边的 n 位清零， x & ( ~0 << n )
  获取 x 的第 n 位值(0 或者 1)，(x >> n) & 1
  获取 x 的第 n 位的幂值，x & (1 << (n - 1))
  仅将第 n 位置为 1，x | (1 << n)
  仅将第 n 位置为 0，x & (~(1 << n))
  将 x 最高位至第 n 位(含)清零，x & ((1 << n) - 1)
  将第 n 位至第 0 位(含)清零，x & (~((1 << (n + 1)) - 1)）
  ```

* 十进制相关的位操作：第 400 题

# 贪心算法（Greedy）

* 第 12 题、第 45 题、第 179 题、第 502 题、第 452 题、第 561 题、第 765 题、第 781 题、第 881 题、第 995 题、第 1221 题、第 1707 题、第 1713 题、第 1736 题、第 1833 题、第 1846 题、第 1877 题、第 330 题、

# 排序（Sort）

* 选择排序（了解）
* 插入排序（熟悉）
* 归并排序（重点）：88题、315题、剑指51题
* 快速排序（重点）：215题、75题
* 堆排序（重点）

# 哈希表（Hash Table）

* 1、36、49、202、127、219、454
* 981、447、448、第 929 题

# 模拟(Stimulation)

* 第 1 题、第 2 题、第 5 题、第 6 题、第 7 题、第238题、第 498 题，

* 矩阵：第 1329 题、

  

# 数学（Math）

* 441 题，29题、第 453 题，第 462 题、第 888 题

* 进制转化：第 504 题

* 数论：第 231 题、第 326 题、第 342 题、第 319 题、第 492 题，第 282 题

* 排列组合：第 357 题

* 等差数列：第 390 题、第 396 题

  
  
  
# 字符串（String）

* 第 273 题，第 43 题、第 468 题、第 1332 题、第 388 题
* 第 796 题、第 557 题



# 数据结构 (Datastructure)

* 第 355 题、第 380 题、第 381 题、第 398 题



# 几何 (geometry)

* 第 391 题、第 1232 题、第 1037题

# 一些奇怪的题目

* 洗牌算法：第 384 题
* 蓄水池算法：第 382 题
* 找规律：第 423 题

# 哈希表
* 第 519 题

# [[NOIP2018 提高组] 货币系统](https://www.luogu.com.cn/problem/P5020)

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。

## 输入格式

输入文件的第一行包含一个整数 $T$，表示数据的组数。

接下来按照如下格式分别给出 $T$ 组数据。 每组数据的第一行包含一个正整数 $n$。接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$。

## 输出格式

输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。

## 样例 #1

### 样例输入 #1

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17
```

### 样例输出 #1

```
2   
5
```

## 提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。

### 解题思路

这道题目看一下样例，可以发现，如果输入数据中的货币中，较大的可以用较小的表示，则完全可以只使用较小的即可，举例来说的话

对于 `[3, 19, 10, 6]` 不难发现，可以用 6 表示，都可以替换为 3 的组合，可以用 19 表示的都可以替换为 10 和 3 的组合，所以与这个货币系统相同的是 `[3, 10]`，所以题目只要求出原来的货币系统中，有多少个数，是不能被其他数的组成即可

将数组按照升序排序，`dp[a]` 表示 a 可否由之前的数组成

状态转移：`dp[j] =`



这道题目的题解区，有一篇题解，对集合部分的知识，讲的很细，可以好好学习一下

### Solution 1:



````c++
#include <bits/stdc++.h>

using namespace std;

static const int kMaxn = 20001;

class Solution {
 public:
    void Solve(vector<int>& coins, int n) {
        sort(coins.begin(), coins.end());
        vector<int> dp(kMaxn, 0);
        
        int ans = n;
        dp[0] = 1;
        for (int i = 0; i < n; ++i) {
            if (dp[coins[i]]) {
                --ans;
                continue;
            }
            
            for (int j = coins[i]; j <= coins[n - 1]; ++j) {
                dp[j] = dp[j] | dp[j - coins[i]];
            }
        }
        cout << ans << endl;
    }
};

int main(void) {
    int T;
    cin >> T;
    
    Solution obj;
    for (int i = 0; i < T; ++i) {
        int n;
        cin >> n;
        vector<int> coins(n, 0);
        for (int i = 0; i < n; ++i) {
            cin >> coins[i];
        }
        obj.Solve(coins, n);
    }

    return 0;
}
````



